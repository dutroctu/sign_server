#!/usr/bin/env python
#
#  User Info
#


from flask import Flask
from flask_restful import Api, Resource, reqparse
from flask import send_file
from flask import render_template
from flask import request, abort, jsonify, send_from_directory
from server.app import app

import os
from server.applog import logD
from server.applog import logE
from server.applog import log
from server import applog as applog 
from server import common as common
import traceback

from server import database as database
from server.database.db_mgr import db
from server.database.account import Account
from datetime import datetime
from server import database as database
from server.app import DEBUG
TAG = "UserInfo"

MAX_HISTORY_LENGTH = 1024
CUT_HISTORY_LENGTH = 20


# User info, match with User object in db
class UserInfo:
    id = None # id generated by id
    username = ""
    fullname = ""
    email = ""
    phone = ""
    password = ""
    type = database.account.ACCOUNT_TYPE_USER
    status = database.account.ACCOUNT_STATUS_NOT_READY

    note = ""

    created_time = ""
    last_login_time = None
    history = ""
    salt = ""
    account = None # from db
    encrypted = False
    default_password = False
    created_by = ""
    type_str = ""
    status_str = ""
    raw_password = "'"  # MUST NOT SAVED TO DB, FOR BACKUP TO BE USED TEMPORORARY ONLY
    failed_counter = 0
    # policy group id, used to manage permission for each account
    # TODO: just reserve for future use, implement it
    policy_group = 0

    # signature for each items, to make sure integrity of this item
    signature = ""
    
    # list of SSH id-rsa of user
    sshrsa = []
    def __init__(self, acc=None, decrypt=True):
        self.id = None # id generated by id
        self.username = ""
        self.fullname = ""
        self.email = ""
        self.phone = ""
        self.password = ""
        self.type = database.account.ACCOUNT_TYPE_USER
        self.status = database.account.ACCOUNT_STATUS_NOT_READY

        self.note = ""

        self.created_time = ""
        self.last_login_time = None
        self.history = ""
        self.salt = ""
        self.account = None # from db
        self.encrypted = False
        self.default_password = False
        self.type_str = ""
        self.status_str = ""
        self.raw_password = ""
        self.created_by = ""
        self.failed_counter = 0
        self.policy_group = 0
        self.signature = ""
        self.sshrsa = []
        if (acc is not None):
            self.fromDB(acc, decrypt)

    # check if user is active
    def is_active(self):
        # TODO: check more, i.e. check with acc info?
        if (self.id is not None and 
            self.username is not None and 
            self.status == database.account.ACCOUNT_STATUS_READY):
            return True
        return False

    def toString(self):
        str = ""
        str += "username: %s;\n" % (self.username if self.username is not None else "None")
        str += "id: %s;\n" % (self.id if self.id is not None else "None")
        str += "type: %d;\n" % self.type
        str += "type: %s;\n" % (database.account.ACCOUNT_TYPE_ID_NAME[self.type] if self.type in database.account.ACCOUNT_TYPE_ID_NAME else "Unknown")
        str += "status: %d;\n" % self.status
        str += "status: %s;\n" % (database.account.ACCOUNT_STATUS_CNAME[self.status] if self.status in database.account.ACCOUNT_STATUS_CNAME else "Unknown")
        str += "password: %s;\n" % (self.password if self.password is not None else "None")
        # TODO: More info?
        return str

    # signature is calculated from:
    # - username
    # - fullname
    # - password
    # - salt
    # - type
    # - status
    # - encrypted
    # - default_password
    # - sshrsa
    def calcSignature(self, acc=None):
        if (DEBUG): logD("calcSignature", TAG)
        import hashlib
        signature = None
        try:
            from server.database.db_mgr import dbMgr
            sha256 = hashlib.sha256()
            usrname = self.username if acc is None else acc.username
            if usrname is not None:
                sha256.update(bytes(usrname, 'utf-8'))

            fullname = self.fullname if acc is None else acc.fullname
            if fullname is not None:
                sha256.update(bytes(fullname, 'utf-8'))

            pwd = self.password if acc is None else acc.password
            if pwd is not None:
                sha256.update(bytes(pwd, 'utf-8'))
            
            salt = self.salt if acc is None else acc.salt
            if salt is not None:
                sha256.update(bytes(salt, 'utf-8'))
            
            sha256.update(bytes("%d" % self.type if acc is None else acc.type, 'utf-8'))
            sha256.update(bytes("%d" % self.status if acc is None else acc.status, 'utf-8'))
            sha256.update(bytes("%d" % self.encrypted if acc is None else acc.encrypted, 'utf-8'))
            sha256.update(bytes("%d" % self.default_password if acc is None else acc.default_password, 'utf-8'))
            sshrsa = self.sshrsa if acc is None else acc.sshrsa
            if sshrsa is not None and len(sshrsa) > 0:
                for rsa in sshrsa:
                    if rsa is not None and len(rsa) > 0:
                        sha256.update(bytes(rsa, 'utf-8'))
            hashit = dbMgr().hashWithKey(sha256.digest())
            signature = hashit.hex()
        except :
            traceback.print_exc()
            applog.logE("calcSignature failed")
            return None
        return signature

    def fromDB(self, acc, decrypt=True, key = None, iv = None):
        if (DEBUG): logD("fromDB")
        from server.database.db_mgr import dbMgr
        if (acc is not None):
            if (DEBUG): logD("acc %s" % acc.toString())
            try:
                self.id = acc.id
                self.type = acc.type
                self.status = acc.status
                self.username = acc.username if not decrypt else dbMgr().decryptDataFromBase64(acc.username, key, iv) if acc.username is not None and len(acc.username) > 0 else ""
                self.fullname = acc.fullname if not decrypt else dbMgr().decryptDataFromBase64(acc.fullname, key, iv)  if acc.fullname is not None and len(acc.fullname) > 0 else ""
                self.email = acc.email if not decrypt else dbMgr().decryptDataFromBase64(acc.email, key, iv)  if acc.email is not None and len(acc.email) > 0 else ""
                self.phone = acc.phone if not decrypt else dbMgr().decryptDataFromBase64(acc.phone, key, iv)  if acc.phone is not None and len(acc.phone) > 0 else ""
                self.password = acc.password if not decrypt else dbMgr().decryptDataFromBase64(acc.password, key, iv)  if acc.password is not None and len(acc.password) > 0 else ""
                self.salt = acc.salt if not decrypt else dbMgr().decryptDataFromBase64(acc.salt, key, iv)  if acc.salt is not None and len(acc.salt) > 0 else ""
                self.note = acc.note if not decrypt else dbMgr().decryptDataFromBase64(acc.note, key, iv)  if acc.note is not None and len(acc.note) > 0 else ""
                self.history = acc.history if not decrypt else dbMgr().decryptDataFromBase64(acc.history, key, iv)  if acc.history is not None and len(acc.history) > 0 else ""
                self.account = acc
                self.encrypted = acc.encrypted
                self.default_password = acc.default_password
                self.created_time = acc.created_time
                self.last_login_time = acc.last_login_time
                self.created_by = acc.created_by
                self.type_str = database.account.ACCOUNT_TYPE_ID_CNAME[acc.type] if acc.type in database.account.ACCOUNT_TYPE_ID_CNAME else "Invalid"
                self.status_str = database.account.ACCOUNT_STATUS_CNAME[acc.status] if acc.status in database.account.ACCOUNT_STATUS_CNAME else "Invalid"
                self.failed_counter = acc.failed_counter
                self.policy_group = acc.policy_group
                self.signature = acc.signature
                if acc.sshrsa is not None:
                    for rsa in acc.sshrsa:
                        if rsa is not None and len(rsa) > 0:
                            self.sshrsa.append(rsa)
            except:
                traceback.print_exc()
                applog.logE("Convert from db object failed, db password not correct?", TAG)
                return common.ERR_EXCEPTION
            return common.ERR_NONE
        else:
            return common.ERR_INVALID_ARGS
    
    def encryptString(self, plain):
        from server.database.db_mgr import dbMgr
        return dbMgr().encryptDataString2Base64(plain) if plain is not None and len(plain) > 0 else "",

    def decryptString(self, cipher):
        from server.database.db_mgr import dbMgr
        return dbMgr().decryptDataFromBase64(cipher) if cipher is not None and len(cipher) > 0 else "",

    def appendHistory(self, history, updateDB=False):
        from server.database.db_mgr import dbMgr
        if history is not None and len(history) > 0:
            self.history = "%s;\n%s: %s" %(self.history, common.current_time(common.TIME_FORMAT_TO_DISPLAY_SHORT), history)
            hislen = len(self.history)
            if (DEBUG): logD("hislen %d" % hislen, TAG)
            if hislen > MAX_HISTORY_LENGTH:
                start = hislen - MAX_HISTORY_LENGTH
                history = self.history[start:hislen]
                self.history = history
                if (DEBUG): logD("self.history %s" % self.history, TAG)
            # change history only, no need to re-calculate hash
            if updateDB:
                if self.account is not None:
                    enc_history = dbMgr().encryptDataString2Base64(self.history)
                    if enc_history is not None:
                        self.account.update(history=enc_history)
                    else:
                        return  common.ERR_FAILED
                else:
                    logE("update history failed, not db object")
                    return common.ERR_NO_DATA
            
            return common.ERR_NONE
        else:
            logE("update history failed, invalid data")
            return common.ERR_INVALID_ARGS

    def getFailAttempt(self):
        return self.failed_counter

    def incFailAttempt(self, inc = True, msg = None, updateDB=True):
        if inc:
            self.failed_counter = self.failed_counter + 1
        else:
            self.failed_counter = self.failed_counter - 1
            if self.failed_counter < 0:
                self.failed_counter  = 0
            
        if updateDB:
            if self.account is not None:
                log("Update last_login_time to db", TAG)
                try:
                    self.account.update(failed_counter=self.failed_counter)
                except:
                    traceback.print_exc()
                    logE("update last_login_time to db failed, exception", TAG)
                    return common.ERR_EXCEPTION
            else:
                logE("update last_login_time to db failed, not db object", TAG)
                return common.ERR_NO_DATA
                    
        return self.appendHistory("%s Failed attempt to %d. %s" % ("inc" if inc else "dec", 
                        self.failed_counter, 
                        msg if msg is not None else ""), 
                        updateDB=True)
    
    def clearFailAttempt(self, msg = None, updateDB=True):
        self.failed_counter = 0
        if updateDB:
            if self.account is not None:
                log("Update last_login_time to db", TAG)
                try:
                    self.account.update(failed_counter=self.failed_counter)
                except:
                    traceback.print_exc()
                    logE("update last_login_time to db failed, exception", TAG)
                    return common.ERR_EXCEPTION
            else:
                logE("update last_login_time to db failed, not db object", TAG)
                return common.ERR_NO_DATA
        return self.appendHistory("Clear Failed attempt. %s" % (msg if msg is not None else ""), updateDB=True)

    # update last login time
    def updateLastLoginTime(self, time=None, updateDB=True):
        if (DEBUG): logD("updateLoginTime", TAG)
        if time is None:
            time = datetime.utcnow()
        
        if (DEBUG): logD("time %s" % str(time), TAG)

        self.last_login_time = time
        if updateDB:
            if self.account is not None:
                log("Update last_login_time to db", TAG)
                try:
                    self.account.update(last_login_time=self.last_login_time)
                except:
                    traceback.print_exc()
                    logE("update last_login_time to db failed, exception", TAG)
                    return common.ERR_EXCEPTION
            else:
                logE("update last_login_time to db failed, not db object", TAG)
                return common.ERR_NO_DATA
        return common.ERR_NONE

    # append new id-rsa for account
    def appendRsa(self, rsa, updateDB=False):
        from server.database.db_mgr import dbMgr
        if rsa is not None and len(rsa) > 0:
            self.sshrsa.append(rsa)
            self.signature = self.calcSignature()
            # change history only, no need to re-calculate hash
            if updateDB:
                if self.account is not None:
                    self.appendHistory("Add rsa %s" % rsa, updateDB=False)
                    enc_history = dbMgr().encryptDataString2Base64(self.history)
                    if enc_history is not None and self.signature is not None:
                        self.account.update(sshrsa = self.sshrsa, history=enc_history, signature=self.signature)
                    else:
                        return  common.ERR_FAILED
                else:
                    logE("appendRsa failed, not db object")
                    return common.ERR_NO_DATA
            
            return common.ERR_NONE
        else:
            logE("appendRsa failed, invalid data")
            return common.ERR_INVALID_ARGS

    # delete id-rsa for account
    def delRsa(self, rsa, updateDB=False):
        from server.database.db_mgr import dbMgr
        if rsa is not None and len(rsa) > 0 and rsa in self.sshrsa:
            self.sshrsa.remove(rsa) # remove existing one

            self.signature = self.calcSignature()
            # change history only, no need to re-calculate hash
            if updateDB:
                if self.account is not None:
                    self.appendHistory("Add rsa %s" % rsa, updateDB=False)
                    enc_history = dbMgr().encryptDataString2Base64(self.history)
                    if enc_history is not None and self.signature is not None:
                        self.account.update(sshrsa = self.sshrsa, history=enc_history, signature=self.signature)
                    else:
                        return  common.ERR_FAILED
                else:
                    logE("appendRsa failed, not db object")
                    return common.ERR_NO_DATA
            
            return common.ERR_NONE
        else:
            logE("appendRsa failed, invalid data")
            return common.ERR_INVALID_ARGS

    # update account status
    def updateStatus(self, status, updateDB=False):
        from server.database.db_mgr import dbMgr
        if status in database.account.ACCOUNT_STATUS_CNAME:
            old = self.status
            self.status = status
            self.signature = self.calcSignature()
            if updateDB:
                if self.account is not None:
                    self.appendHistory("Update account status from %d to %d" %(old, self.status), updateDB=False)
                    enc_history = dbMgr().encryptDataString2Base64(self.history)
                    if enc_history is not None and self.signature is not None:
                        self.account.update(status = self.status, history=enc_history, signature=self.signature)
                    else:
                        return  common.ERR_FAILED
                else:
                    logE("update history failed, not db object")
                    return common.ERR_NO_DATA
            
            return common.ERR_NONE
        else:
            logE("update status failed, invalid data")
            return common.ERR_INVALID_ARGS

    # update account signature
    def updateSignature(self, signature=None):
        from server.database.db_mgr import dbMgr
        sign = signature if signature is not None else self.calcSignature()
        if sign is not None:
            self.account.update(signature=sign)
            return common.ERR_NONE
        else:
            logE("update sign failed, invalid data")
            return common.ERR_INVALID_ARGS

    def toDB(self, createNew=True, key = None, iv = None):
        from server.database.db_mgr import dbMgr
        try:
            newacc = None
            signature = self.calcSignature()
            if createNew or self.account is None:
                newacc = Account(
                    username = dbMgr().encryptDataString2Base64(self.username, key, iv) if self.username is not None and len(self.username) > 0 else "",
                    fullname = dbMgr().encryptDataString2Base64(self.fullname, key, iv) if self.fullname is not None and len(self.fullname) > 0 else "",
                    password = dbMgr().encryptDataString2Base64(self.password, key, iv) if self.password is not None and len(self.password) > 0 else "",
                    email = dbMgr().encryptDataString2Base64(self.email, key, iv) if self.email is not None and len(self.email) > 0 else "",
                    phone = dbMgr().encryptDataString2Base64(self.phone, key, iv) if self.phone is not None and len(self.phone) > 0 else "",
                    salt = dbMgr().encryptDataString2Base64(self.salt, key, iv) if self.salt is not None and len(self.salt) > 0 else "",
                    note = dbMgr().encryptDataString2Base64(self.note, key, iv) if self.note is not None and len(self.note) > 0 else "",
                    history =  dbMgr().encryptDataString2Base64(self.history, key, iv) if self.history is not None and len(self.history) > 0 else "",
                    type = self.type,
                    created_time = self.created_time if self.created_time is not None else None,
                    status = database.account.ACCOUNT_STATUS_NOT_READY, # should not ready yet, ready later
                    encrypted = True,
                    default_password = self.default_password,
                    last_login_time = self.last_login_time if self.last_login_time is not None else None,
                    created_by = self.created_by,
                    failed_counter = self.failed_counter,
                    policy_group = self.policy_group,
                    signature = signature,
                    sshrsa = self.sshrsa,
                )
            else:
                self.account.username = dbMgr().encryptDataString2Base64(self.username, key, iv) if self.username is not None and len(self.username) > 0 else ""
                self.account.fullname = dbMgr().encryptDataString2Base64(self.fullname, key, iv) if self.fullname is not None and len(self.fullname) > 0 else ""
                self.account.password = dbMgr().encryptDataString2Base64(self.password, key, iv) if self.password is not None and len(self.password) > 0 else ""
                self.account.email = dbMgr().encryptDataString2Base64(self.email, key, iv) if self.email is not None and len(self.email) > 0 else ""
                self.account.phone = dbMgr().encryptDataString2Base64(self.phone, key, iv) if self.phone is not None and len(self.phone) > 0 else ""
                self.account.salt = dbMgr().encryptDataString2Base64(self.salt, key, iv) if self.salt is not None and len(self.salt) > 0 else ""
                self.account.note = dbMgr().encryptDataString2Base64(self.note, key, iv) if self.note is not None and len(self.note) > 0 else ""
                self.account.history = dbMgr().encryptDataString2Base64(self.history, key, iv) if self.history is not None and len(self.history) > 0 else ""
                self.account.type = self.type
                # self.account.created_time = self.created_time if self.created_time is not None and len(self.created_time) > 0 else None,
                # self.account.history = self.history
                self.account.status = self.status # should not ready yet, ready later
                self.account.encrypted = True
                self.account.default_password = self.default_password
                self.account.last_login_time = self.last_login_time if self.last_login_time is not None else None
                self.account.created_by = self.created_by
                self.account.failed_counter = self.failed_counter
                self.account.policy_group = self.policy_group
                self.account.signature = signature
                self.account.sshrsa = self.sshrsa
                newacc = self.account

            return newacc
        except:
            traceback.print_exc()
            applog.logE("Convert to db object failed, db password not correct?", TAG)
            return None

    def validate(self):
        if (DEBUG): logD("validate user info")
        if (self.username is None or len(self.username) == 0):
            logE("Invalid username")
            return False

        if self.type not in database.account.ACCOUNT_TYPE_ID_NAME:
            logE("Invalid type %d" % self.type)
            return False
        
        
        if self.status not in database.account.ACCOUNT_STATUS_CNAME:
            logE("Invalid status %d" % self.status)
            return False

        calcSign = self.calcSignature()
        if self.signature is not None and self.signature != calcSign:
            logE("mistmatch signature, expected %s calc %s" % (self.signature, calcSign), TAG)
            return False


        return True

    def validateSignature(self, signature=None):
        if (DEBUG): logD("validate validateSignature")

        signature2check = signature if signature is not None else self.signature
        calsignature = self.calcSignature()
        if signature2check is None or calsignature is None or signature2check != calsignature:
            logE("mistmatch signature, expected %s calc %s" % (signature2check, calsignature), TAG)
            return False

        return True